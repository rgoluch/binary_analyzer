digraph code {
	graph [bgcolor=azure fontsize=8 fontname="Courier" splines="ortho"];
	node [fillcolor=gray style=filled shape=box];
	edge [arrowhead="normal"];
	"0x0010fd94" [URL="sym.icmp_mkpkt/0x0010fd94", fillcolor="#c19c00",color="#c19c00", fontname="Courier",label="  ; CALL XREF from sym.icmp_in @ 0x10f90e\l  ; CALL XREF from sym.icmp_send @ 0x10fd55\l308: sym.icmp_mkpkt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch);\l; var int32_t var_24h @ ebp-0x24\l; var int32_t var_20h @ ebp-0x20\l; var int32_t var_1ch @ ebp-0x1c\l; var int32_t var_ch @ ebp-0xc\l; var int32_t var_4h @ ebp-0x4\l; arg int32_t arg_8h @ ebp+0x8\l; arg int32_t arg_ch @ ebp+0xc\l; arg int32_t arg_10h @ ebp+0x10\l; arg int32_t arg_14h @ ebp+0x14\l; arg int32_t arg_18h @ ebp+0x18\l; arg int32_t arg_1ch @ ebp+0x1c\l0x0010fd94      push ebp\l0x0010fd95      mov ebp, esp\l0x0010fd97      push ebx\l0x0010fd98      sub esp, 0x24\l0x0010fd9b      call sym.__x86.get_pc_thunk.bx\l0x0010fda0      add ebx, 0x11260\l0x0010fda6      mov ecx, dword [arg_ch]\l0x0010fda9      mov edx, dword [arg_10h]\l0x0010fdac      mov eax, dword [arg_14h]\l0x0010fdaf      mov word [var_1ch], cx\l0x0010fdb3      mov word [var_20h], dx\l0x0010fdb7      mov word [var_24h], ax\l0x0010fdbb      mov eax, obj.netbufpool                                ; 0x1401e0\l0x0010fdc1      mov eax, dword [eax]\l0x0010fdc3      sub esp, 0xc\l0x0010fdc6      push eax\l0x0010fdc7      call sym.getbuf\l0x0010fdcc      add esp, 0x10\l0x0010fdcf      mov dword [var_ch], eax\l0x0010fdd2      cmp dword [var_ch], 0xffffffff\l0x0010fdd6      jne 0x10fdea\l"]
	"0x0010fdd8" [URL="sym.icmp_mkpkt/0x0010fdd8", fillcolor="#c19c00",color="#c19c00", fontname="Courier",label="0x0010fdd8      sub esp, 0xc\l0x0010fddb      lea eax, [ebx - 0x7f8c]\l0x0010fde1      push eax\l0x0010fde2      call sym.panic\l0x0010fde7      add esp, 0x10\l"]
	"0x0010fdea" [URL="sym.icmp_mkpkt/0x0010fdea", fillcolor="#c19c00",color="#c19c00", fontname="Courier",label="; CODE XREF from sym.icmp_mkpkt @ 0x10fdd6\l0x0010fdea      mov eax, dword [var_ch]\l0x0010fded      lea edx, [eax + 6]\l0x0010fdf0      sub esp, 4\l0x0010fdf3      push 6                                                 ; 6\l0x0010fdf5      mov eax, obj.NetData                                   ; 0x140200\l0x0010fdfb      lea eax, [eax + 0x21]\l0x0010fdfe      push eax\l0x0010fdff      push edx\l0x0010fe00      call sym.memcpy                                        ; void *memcpy(void *s1, const void *s2, size_t n)\l0x0010fe05      add esp, 0x10\l0x0010fe08      mov eax, dword [var_ch]\l0x0010fe0b      mov word [eax + 0xc], 0x800                            ; [0x800:2]=0xffff ; 2048\l0x0010fe11      mov eax, dword [var_ch]\l0x0010fe14      mov byte [eax + 0xe], 0x45                             ; 'E'\l                                                                       ; [0x45:1]=255 ; 69\l0x0010fe18      mov eax, dword [var_ch]\l0x0010fe1b      mov byte [eax + 0xf], 0\l0x0010fe1f      mov eax, dword [arg_1ch]\l0x0010fe22      add eax, 0x1c                                          ; 28\l0x0010fe25      mov edx, dword [var_ch]\l0x0010fe28      mov word [edx + 0x10], ax\l0x0010fe2c      mov eax, dword [ebx - 0x109c]\l0x0010fe32      lea edx, [eax + 1]\l0x0010fe35      mov dword [ebx - 0x109c], edx\l0x0010fe3b      mov edx, dword [var_ch]\l0x0010fe3e      mov word [edx + 0x12], ax\l0x0010fe42      mov eax, dword [var_ch]\l0x0010fe45      mov word [eax + 0x14], 0\l0x0010fe4b      mov eax, dword [var_ch]\l0x0010fe4e      mov byte [eax + 0x16], 0xff                            ; [0xff:1]=255 ; 255\l0x0010fe52      mov eax, dword [var_ch]\l0x0010fe55      mov byte [eax + 0x17], 1\l0x0010fe59      mov eax, dword [var_ch]\l0x0010fe5c      mov word [eax + 0x18], 0\l0x0010fe62      mov eax, obj.NetData                                   ; 0x140200\l0x0010fe68      mov edx, dword [eax]\l0x0010fe6a      mov eax, dword [var_ch]\l0x0010fe6d      mov dword [eax + 0x1a], edx\l0x0010fe70      mov eax, dword [var_ch]\l0x0010fe73      mov edx, dword [arg_8h]\l0x0010fe76      mov dword [eax + 0x1e], edx\l0x0010fe79      mov eax, dword [var_1ch]\l0x0010fe7c      mov dl, al\l0x0010fe7e      mov eax, dword [var_ch]\l0x0010fe81      mov byte [eax + 0x22], dl\l0x0010fe84      mov eax, dword [var_ch]\l0x0010fe87      mov byte [eax + 0x23], 0\l0x0010fe8b      mov eax, dword [var_ch]\l0x0010fe8e      mov word [eax + 0x24], 0\l0x0010fe94      mov edx, dword [var_ch]\l0x0010fe97      mov eax, dword [var_20h]\l0x0010fe9a      mov word [edx + 0x26], ax\l0x0010fe9e      mov edx, dword [var_ch]\l0x0010fea1      mov eax, dword [var_24h]\l0x0010fea4      mov word [edx + 0x28], ax\l0x0010fea8      mov eax, dword [var_ch]\l0x0010feab      add eax, 0x2a                                          ; 42\l0x0010feae      sub esp, 4\l0x0010feb1      push dword [arg_1ch]\l0x0010feb4      push dword [arg_18h]\l0x0010feb7      push eax\l0x0010feb8      call sym.memcpy                                        ; void *memcpy(void *s1, const void *s2, size_t n)\l0x0010febd      add esp, 0x10\l0x0010fec0      mov eax, dword [var_ch]\l0x0010fec3      mov ebx, dword [var_4h]\l0x0010fec6      leave\l0x0010fec7      ret\l"]
        "0x0010fd94" -> "0x0010fdea" [color="#13a10e"];
        "0x0010fd94" -> "0x0010fdd8" [color="#c50f1f"];
        "0x0010fdd8" -> "0x0010fdea" [color="#0037da"];
}
